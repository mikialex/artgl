# 关于渲染的概念模型

当我们认真做一件事情的时候，一开始就有必要好好的系统的了解这件事情到底是如何发生的，整个流程，体系是如何work的，而不是稀里糊涂的盲目尝试和做设计，这样总是事倍功半。

## 我们要做哪些封装和抽象？

原始的webgl是一个状态机，所以api的使用是不直观的，甚至说奇怪的。因为实际执行的效果，取决于状态机的状态，而这些状态，对于上层用户而言，过于晦涩和底层，非常易错，非常繁琐，因而需要封装和抽象，以有效的隔离复杂度。

当你bindbuffer， bufferdata， enablexxxarray， drawelement， 调用了一堆命令画一个东西，流程是很长和复杂的，只要其中任何一个步骤不对，就不能达成需求。所以封装的直观意义在于，我只要调用1个命令，1个动作，就能完成之前很多行才能完成的画一个东西，另一个方面，至于这个东西画成什么样子，这个东西是什么样子，我应该把这个东西本身做一个封装，而不是散落在gl的一堆命令之中。对应起来：我们抽象封装的是**渲染的功能/命令**，和**渲染的资源**。

在web的环境下，用户能够创建多个canvas，创建多个不同的webglcontext， 所以成熟的webgl引擎，应该能做到一份数据能够在多个context下进行渲染。所以这就使得我们存在一个假设，用以创建context绑定的gl资源的数据， 不会在创建完gl资源结束后被释放，而是能够创建其他context的gl资源。用户本身持有这个数据，作为渲染内容的描述，而webgl引擎，负责资源的处理工作，这样的设计，能够向用户屏蔽gl资源创建和维护的流程，屏蔽多context的额外流程。

由上面的例子不难看出，渲染的资源/数据，其实是可以分为几类的。我们谈论的资源，其实有三种，第一种是所谓的**场景数据**，就是上文提到的用户本身持有的数据。第二种，是所谓的**gl资源**，gl资源的重要特点是context相关的，属于某一个context，由场景数据生成。第三种，是所谓**渲染数据**。关于渲染数据，可以理解为为了渲染而存在的中间数据，和gl没有关系，但是和渲染或者渲染的优化有直接的关系，对顶层用户是透明的。场景数据是描述了这个东西是什么，但是这个描述对应到实际的绘制命令，还有相当的距离。引擎会根据用户提供的场景数据，创建或者同步gl资源和渲染数据的更新，并使用它们进行实际的gl调用完成绘制过程。

